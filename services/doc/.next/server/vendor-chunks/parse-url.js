"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-url";
exports.ids = ["vendor-chunks/parse-url"];
exports.modules = {

/***/ "../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js":
/*!******************************************************************************************************************!*\
  !*** ../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar parsePath = __webpack_require__(/*! parse-path */ \"../../../../.yarn/berry/cache/parse-path-npm-7.0.0-ceda41e594-10c0.zip/node_modules/parse-path/lib/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar parsePath__default = /*#__PURE__*/_interopDefaultLegacy(parsePath);\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nconst DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';\nconst DATA_URL_DEFAULT_CHARSET = 'us-ascii';\n\nconst testParameter = (name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);\n\nconst normalizeDataURL = (urlString, {stripHash}) => {\n\tconst match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n\n\tif (!match) {\n\t\tthrow new Error(`Invalid URL: ${urlString}`);\n\t}\n\n\tlet {type, data, hash} = match.groups;\n\tconst mediaType = type.split(';');\n\thash = stripHash ? '' : hash;\n\n\tlet isBase64 = false;\n\tif (mediaType[mediaType.length - 1] === 'base64') {\n\t\tmediaType.pop();\n\t\tisBase64 = true;\n\t}\n\n\t// Lowercase MIME type\n\tconst mimeType = (mediaType.shift() || '').toLowerCase();\n\tconst attributes = mediaType\n\t\t.map(attribute => {\n\t\t\tlet [key, value = ''] = attribute.split('=').map(string => string.trim());\n\n\t\t\t// Lowercase `charset`\n\t\t\tif (key === 'charset') {\n\t\t\t\tvalue = value.toLowerCase();\n\n\t\t\t\tif (value === DATA_URL_DEFAULT_CHARSET) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn `${key}${value ? `=${value}` : ''}`;\n\t\t})\n\t\t.filter(Boolean);\n\n\tconst normalizedMediaType = [\n\t\t...attributes,\n\t];\n\n\tif (isBase64) {\n\t\tnormalizedMediaType.push('base64');\n\t}\n\n\tif (normalizedMediaType.length > 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {\n\t\tnormalizedMediaType.unshift(mimeType);\n\t}\n\n\treturn `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;\n};\n\nfunction normalizeUrl(urlString, options) {\n\toptions = {\n\t\tdefaultProtocol: 'http:',\n\t\tnormalizeProtocol: true,\n\t\tforceHttp: false,\n\t\tforceHttps: false,\n\t\tstripAuthentication: true,\n\t\tstripHash: false,\n\t\tstripTextFragment: true,\n\t\tstripWWW: true,\n\t\tremoveQueryParameters: [/^utm_\\w+/i],\n\t\tremoveTrailingSlash: true,\n\t\tremoveSingleSlash: true,\n\t\tremoveDirectoryIndex: false,\n\t\tsortQueryParameters: true,\n\t\t...options,\n\t};\n\n\turlString = urlString.trim();\n\n\t// Data URL\n\tif (/^data:/i.test(urlString)) {\n\t\treturn normalizeDataURL(urlString, options);\n\t}\n\n\tif (/^view-source:/i.test(urlString)) {\n\t\tthrow new Error('`view-source:` is not supported as it is a non-standard protocol');\n\t}\n\n\tconst hasRelativeProtocol = urlString.startsWith('//');\n\tconst isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n\n\t// Prepend protocol\n\tif (!isRelativeUrl) {\n\t\turlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n\t}\n\n\tconst urlObject = new URL(urlString);\n\n\tif (options.forceHttp && options.forceHttps) {\n\t\tthrow new Error('The `forceHttp` and `forceHttps` options cannot be used together');\n\t}\n\n\tif (options.forceHttp && urlObject.protocol === 'https:') {\n\t\turlObject.protocol = 'http:';\n\t}\n\n\tif (options.forceHttps && urlObject.protocol === 'http:') {\n\t\turlObject.protocol = 'https:';\n\t}\n\n\t// Remove auth\n\tif (options.stripAuthentication) {\n\t\turlObject.username = '';\n\t\turlObject.password = '';\n\t}\n\n\t// Remove hash\n\tif (options.stripHash) {\n\t\turlObject.hash = '';\n\t} else if (options.stripTextFragment) {\n\t\turlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, '');\n\t}\n\n\t// Remove duplicate slashes if not preceded by a protocol\n\t// NOTE: This could be implemented using a single negative lookbehind\n\t// regex, but we avoid that to maintain compatibility with older js engines\n\t// which do not have support for that feature.\n\tif (urlObject.pathname) {\n\t\t// TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\\b[a-z][a-z\\d+\\-.]{1,50}:)\\/{2,}/g, '/');` when Safari supports negative lookbehind.\n\n\t\t// Split the string by occurrences of this protocol regex, and perform\n\t\t// duplicate-slash replacement on the strings between those occurrences\n\t\t// (if any).\n\t\tconst protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n\n\t\tlet lastIndex = 0;\n\t\tlet result = '';\n\t\tfor (;;) {\n\t\t\tconst match = protocolRegex.exec(urlObject.pathname);\n\t\t\tif (!match) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst protocol = match[0];\n\t\t\tconst protocolAtIndex = match.index;\n\t\t\tconst intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n\n\t\t\tresult += intermediate.replace(/\\/{2,}/g, '/');\n\t\t\tresult += protocol;\n\t\t\tlastIndex = protocolAtIndex + protocol.length;\n\t\t}\n\n\t\tconst remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n\t\tresult += remnant.replace(/\\/{2,}/g, '/');\n\n\t\turlObject.pathname = result;\n\t}\n\n\t// Decode URI octets\n\tif (urlObject.pathname) {\n\t\ttry {\n\t\t\turlObject.pathname = decodeURI(urlObject.pathname);\n\t\t} catch {}\n\t}\n\n\t// Remove directory index\n\tif (options.removeDirectoryIndex === true) {\n\t\toptions.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n\t}\n\n\tif (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n\t\tlet pathComponents = urlObject.pathname.split('/');\n\t\tconst lastComponent = pathComponents[pathComponents.length - 1];\n\n\t\tif (testParameter(lastComponent, options.removeDirectoryIndex)) {\n\t\t\tpathComponents = pathComponents.slice(0, -1);\n\t\t\turlObject.pathname = pathComponents.slice(1).join('/') + '/';\n\t\t}\n\t}\n\n\tif (urlObject.hostname) {\n\t\t// Remove trailing dot\n\t\turlObject.hostname = urlObject.hostname.replace(/\\.$/, '');\n\n\t\t// Remove `www.`\n\t\tif (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n\t\t\t// Each label should be max 63 at length (min: 1).\n\t\t\t// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n\t\t\t// Each TLD should be up to 63 characters long (min: 2).\n\t\t\t// It is technically possible to have a single character TLD, but none currently exist.\n\t\t\turlObject.hostname = urlObject.hostname.replace(/^www\\./, '');\n\t\t}\n\t}\n\n\t// Remove query unwanted parameters\n\tif (Array.isArray(options.removeQueryParameters)) {\n\t\t// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.\n\t\tfor (const key of [...urlObject.searchParams.keys()]) {\n\t\t\tif (testParameter(key, options.removeQueryParameters)) {\n\t\t\t\turlObject.searchParams.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (options.removeQueryParameters === true) {\n\t\turlObject.search = '';\n\t}\n\n\t// Sort query parameters\n\tif (options.sortQueryParameters) {\n\t\turlObject.searchParams.sort();\n\n\t\t// Calling `.sort()` encodes the search parameters, so we need to decode them again.\n\t\ttry {\n\t\t\turlObject.search = decodeURIComponent(urlObject.search);\n\t\t} catch {}\n\t}\n\n\tif (options.removeTrailingSlash) {\n\t\turlObject.pathname = urlObject.pathname.replace(/\\/$/, '');\n\t}\n\n\tconst oldUrlString = urlString;\n\n\t// Take advantage of many of the Node `url` normalizations\n\turlString = urlObject.toString();\n\n\tif (!options.removeSingleSlash && urlObject.pathname === '/' && !oldUrlString.endsWith('/') && urlObject.hash === '') {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Remove ending `/` unless removeSingleSlash is false\n\tif ((options.removeTrailingSlash || urlObject.pathname === '/') && urlObject.hash === '' && options.removeSingleSlash) {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Restore relative protocol, if applicable\n\tif (hasRelativeProtocol && !options.normalizeProtocol) {\n\t\turlString = urlString.replace(/^http:\\/\\//, '//');\n\t}\n\n\t// Remove http/https\n\tif (options.stripProtocol) {\n\t\turlString = urlString.replace(/^(?:https?:)?\\/\\//, '');\n\t}\n\n\treturn urlString;\n}\n\n// Dependencies\n\n/**\n * parseUrl\n * Parses the input url.\n *\n * **Note**: This *throws* if invalid urls are provided.\n *\n * @name parseUrl\n * @function\n * @param {String} url The input url.\n * @param {Boolean|Object} normalize Whether to normalize the url or not.\n *                         Default is `false`. If `true`, the url will\n *                         be normalized. If an object, it will be the\n *                         options object sent to [`normalize-url`](https://github.com/sindresorhus/normalize-url).\n *\n *                         For SSH urls, normalize won't work.\n *\n * @return {Object} An object containing the following fields:\n *\n *    - `protocols` (Array): An array with the url protocols (usually it has one element).\n *    - `protocol` (String): The first protocol, `\"ssh\"` (if the url is a ssh url) or `\"file\"`.\n *    - `port` (null|Number): The domain port.\n *    - `resource` (String): The url domain (including subdomains).\n *    - `user` (String): The authentication user (usually for ssh urls).\n *    - `pathname` (String): The url pathname.\n *    - `hash` (String): The url hash.\n *    - `search` (String): The url querystring value.\n *    - `href` (String): The input url.\n *    - `query` (Object): The url querystring, parsed as object.\n *    - `parse_failed` (Boolean): Whether the parsing failed or not.\n */\nconst parseUrl = (url, normalize = false) => {\n\n    // Constants\n    const GIT_RE = /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\\/\\/)([\\w\\.\\-@]+)[\\/:]([\\~,\\.\\w,\\-,\\_,\\/]+?(?:\\.git|\\/)?)$/;\n\n    const throwErr = msg => {\n        const err = new Error(msg);\n        err.subject_url = url;\n        throw err\n    };\n\n    if (typeof url !== \"string\" || !url.trim()) {\n        throwErr(\"Invalid url.\");\n    }\n\n    if (url.length > parseUrl.MAX_INPUT_LENGTH) {\n        throwErr(\"Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH.\");\n    }\n\n    if (normalize) {\n        if (typeof normalize !== \"object\") {\n            normalize = {\n                stripHash: false\n            };\n        }\n        url = normalizeUrl(url, normalize);\n    }\n\n    const parsed = parsePath__default[\"default\"](url);\n\n    // Potential git-ssh urls\n    if (parsed.parse_failed) {\n        const matched = parsed.href.match(GIT_RE);\n\n        if (matched) {\n            parsed.protocols = [\"ssh\"];\n            parsed.protocol = \"ssh\";\n            parsed.resource = matched[2];\n            parsed.host = matched[2];\n            parsed.user = matched[1];\n            parsed.pathname = `/${matched[3]}`;\n            parsed.parse_failed = false;\n        } else {\n            throwErr(\"URL parsing failed.\");\n        }\n    }\n\n    return parsed;\n};\n\nparseUrl.MAX_INPUT_LENGTH = 2048;\n\nmodule.exports = parseUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLnlhcm4vYmVycnkvY2FjaGUvcGFyc2UtdXJsLW5wbS04LjEuMC0wOTk1ZjE1YzM0LTEwYzAuemlwL25vZGVfbW9kdWxlcy9wYXJzZS11cmwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQywrSEFBWTs7QUFFcEMscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxVQUFVO0FBQ2hEOztBQUVBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7O0FBRUEsTUFBTSxrQkFBa0I7QUFDeEIsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxJQUFJLEVBQUUsWUFBWSxNQUFNLE9BQU87QUFDNUMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiwyQkFBMkIsR0FBRyxHQUFHLDhCQUE4QixFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILEtBQUssS0FBSyxHQUFHLFNBQVM7O0FBRXhJO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsR0FBRzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsS0FBSyxhQUFhLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsS0FBSzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0dWR5L2RvY3MvLi4vLi4vLi4vLi4vLnlhcm4vYmVycnkvY2FjaGUvcGFyc2UtdXJsLW5wbS04LjEuMC0wOTk1ZjE1YzM0LTEwYzAuemlwL25vZGVfbW9kdWxlcy9wYXJzZS11cmwvZGlzdC9pbmRleC5qcz9iN2UzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlUGF0aCA9IHJlcXVpcmUoJ3BhcnNlLXBhdGgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBwYXJzZVBhdGhfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHBhcnNlUGF0aCk7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG5jb25zdCBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSA9ICd0ZXh0L3BsYWluJztcbmNvbnN0IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCA9ICd1cy1hc2NpaSc7XG5cbmNvbnN0IHRlc3RQYXJhbWV0ZXIgPSAobmFtZSwgZmlsdGVycykgPT4gZmlsdGVycy5zb21lKGZpbHRlciA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHAgPyBmaWx0ZXIudGVzdChuYW1lKSA6IGZpbHRlciA9PT0gbmFtZSk7XG5cbmNvbnN0IG5vcm1hbGl6ZURhdGFVUkwgPSAodXJsU3RyaW5nLCB7c3RyaXBIYXNofSkgPT4ge1xuXHRjb25zdCBtYXRjaCA9IC9eZGF0YTooPzx0eXBlPlteLF0qPyksKD88ZGF0YT5bXiNdKj8pKD86Iyg/PGhhc2g+LiopKT8kLy5leGVjKHVybFN0cmluZyk7XG5cblx0aWYgKCFtYXRjaCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7dXJsU3RyaW5nfWApO1xuXHR9XG5cblx0bGV0IHt0eXBlLCBkYXRhLCBoYXNofSA9IG1hdGNoLmdyb3Vwcztcblx0Y29uc3QgbWVkaWFUeXBlID0gdHlwZS5zcGxpdCgnOycpO1xuXHRoYXNoID0gc3RyaXBIYXNoID8gJycgOiBoYXNoO1xuXG5cdGxldCBpc0Jhc2U2NCA9IGZhbHNlO1xuXHRpZiAobWVkaWFUeXBlW21lZGlhVHlwZS5sZW5ndGggLSAxXSA9PT0gJ2Jhc2U2NCcpIHtcblx0XHRtZWRpYVR5cGUucG9wKCk7XG5cdFx0aXNCYXNlNjQgPSB0cnVlO1xuXHR9XG5cblx0Ly8gTG93ZXJjYXNlIE1JTUUgdHlwZVxuXHRjb25zdCBtaW1lVHlwZSA9IChtZWRpYVR5cGUuc2hpZnQoKSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblx0Y29uc3QgYXR0cmlidXRlcyA9IG1lZGlhVHlwZVxuXHRcdC5tYXAoYXR0cmlidXRlID0+IHtcblx0XHRcdGxldCBba2V5LCB2YWx1ZSA9ICcnXSA9IGF0dHJpYnV0ZS5zcGxpdCgnPScpLm1hcChzdHJpbmcgPT4gc3RyaW5nLnRyaW0oKSk7XG5cblx0XHRcdC8vIExvd2VyY2FzZSBgY2hhcnNldGBcblx0XHRcdGlmIChrZXkgPT09ICdjaGFyc2V0Jykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSBEQVRBX1VSTF9ERUZBVUxUX0NIQVJTRVQpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGAke2tleX0ke3ZhbHVlID8gYD0ke3ZhbHVlfWAgOiAnJ31gO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihCb29sZWFuKTtcblxuXHRjb25zdCBub3JtYWxpemVkTWVkaWFUeXBlID0gW1xuXHRcdC4uLmF0dHJpYnV0ZXMsXG5cdF07XG5cblx0aWYgKGlzQmFzZTY0KSB7XG5cdFx0bm9ybWFsaXplZE1lZGlhVHlwZS5wdXNoKCdiYXNlNjQnKTtcblx0fVxuXG5cdGlmIChub3JtYWxpemVkTWVkaWFUeXBlLmxlbmd0aCA+IDAgfHwgKG1pbWVUeXBlICYmIG1pbWVUeXBlICE9PSBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSkpIHtcblx0XHRub3JtYWxpemVkTWVkaWFUeXBlLnVuc2hpZnQobWltZVR5cGUpO1xuXHR9XG5cblx0cmV0dXJuIGBkYXRhOiR7bm9ybWFsaXplZE1lZGlhVHlwZS5qb2luKCc7Jyl9LCR7aXNCYXNlNjQgPyBkYXRhLnRyaW0oKSA6IGRhdGF9JHtoYXNoID8gYCMke2hhc2h9YCA6ICcnfWA7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVVcmwodXJsU3RyaW5nLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0ZGVmYXVsdFByb3RvY29sOiAnaHR0cDonLFxuXHRcdG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuXHRcdGZvcmNlSHR0cDogZmFsc2UsXG5cdFx0Zm9yY2VIdHRwczogZmFsc2UsXG5cdFx0c3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcblx0XHRzdHJpcEhhc2g6IGZhbHNlLFxuXHRcdHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuXHRcdHN0cmlwV1dXOiB0cnVlLFxuXHRcdHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG5cdFx0cmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcblx0XHRyZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcblx0XHRyZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG5cdFx0c29ydFF1ZXJ5UGFyYW1ldGVyczogdHJ1ZSxcblx0XHQuLi5vcHRpb25zLFxuXHR9O1xuXG5cdHVybFN0cmluZyA9IHVybFN0cmluZy50cmltKCk7XG5cblx0Ly8gRGF0YSBVUkxcblx0aWYgKC9eZGF0YTovaS50ZXN0KHVybFN0cmluZykpIHtcblx0XHRyZXR1cm4gbm9ybWFsaXplRGF0YVVSTCh1cmxTdHJpbmcsIG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKC9edmlldy1zb3VyY2U6L2kudGVzdCh1cmxTdHJpbmcpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdgdmlldy1zb3VyY2U6YCBpcyBub3Qgc3VwcG9ydGVkIGFzIGl0IGlzIGEgbm9uLXN0YW5kYXJkIHByb3RvY29sJyk7XG5cdH1cblxuXHRjb25zdCBoYXNSZWxhdGl2ZVByb3RvY29sID0gdXJsU3RyaW5nLnN0YXJ0c1dpdGgoJy8vJyk7XG5cdGNvbnN0IGlzUmVsYXRpdmVVcmwgPSAhaGFzUmVsYXRpdmVQcm90b2NvbCAmJiAvXlxcLipcXC8vLnRlc3QodXJsU3RyaW5nKTtcblxuXHQvLyBQcmVwZW5kIHByb3RvY29sXG5cdGlmICghaXNSZWxhdGl2ZVVybCkge1xuXHRcdHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD8hKD86XFx3KzopP1xcL1xcLyl8XlxcL1xcLy8sIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKTtcblx0fVxuXG5cdGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsU3RyaW5nKTtcblxuXHRpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgb3B0aW9ucy5mb3JjZUh0dHBzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYGZvcmNlSHR0cGAgYW5kIGBmb3JjZUh0dHBzYCBvcHRpb25zIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyJyk7XG5cdH1cblxuXHRpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuXHRcdHVybE9iamVjdC5wcm90b2NvbCA9ICdodHRwOic7XG5cdH1cblxuXHRpZiAob3B0aW9ucy5mb3JjZUh0dHBzICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuXHRcdHVybE9iamVjdC5wcm90b2NvbCA9ICdodHRwczonO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGF1dGhcblx0aWYgKG9wdGlvbnMuc3RyaXBBdXRoZW50aWNhdGlvbikge1xuXHRcdHVybE9iamVjdC51c2VybmFtZSA9ICcnO1xuXHRcdHVybE9iamVjdC5wYXNzd29yZCA9ICcnO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGhhc2hcblx0aWYgKG9wdGlvbnMuc3RyaXBIYXNoKSB7XG5cdFx0dXJsT2JqZWN0Lmhhc2ggPSAnJztcblx0fSBlbHNlIGlmIChvcHRpb25zLnN0cmlwVGV4dEZyYWdtZW50KSB7XG5cdFx0dXJsT2JqZWN0Lmhhc2ggPSB1cmxPYmplY3QuaGFzaC5yZXBsYWNlKC8jPzp+OnRleHQuKj8kL2ksICcnKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBkdXBsaWNhdGUgc2xhc2hlcyBpZiBub3QgcHJlY2VkZWQgYnkgYSBwcm90b2NvbFxuXHQvLyBOT1RFOiBUaGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIGEgc2luZ2xlIG5lZ2F0aXZlIGxvb2tiZWhpbmRcblx0Ly8gcmVnZXgsIGJ1dCB3ZSBhdm9pZCB0aGF0IHRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBqcyBlbmdpbmVzXG5cdC8vIHdoaWNoIGRvIG5vdCBoYXZlIHN1cHBvcnQgZm9yIHRoYXQgZmVhdHVyZS5cblx0aWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuXHRcdC8vIFRPRE86IFJlcGxhY2UgZXZlcnl0aGluZyBiZWxvdyB3aXRoIGB1cmxPYmplY3QucGF0aG5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvKD88IVxcYlthLXpdW2EtelxcZCtcXC0uXXsxLDUwfTopXFwvezIsfS9nLCAnLycpO2Agd2hlbiBTYWZhcmkgc3VwcG9ydHMgbmVnYXRpdmUgbG9va2JlaGluZC5cblxuXHRcdC8vIFNwbGl0IHRoZSBzdHJpbmcgYnkgb2NjdXJyZW5jZXMgb2YgdGhpcyBwcm90b2NvbCByZWdleCwgYW5kIHBlcmZvcm1cblx0XHQvLyBkdXBsaWNhdGUtc2xhc2ggcmVwbGFjZW1lbnQgb24gdGhlIHN0cmluZ3MgYmV0d2VlbiB0aG9zZSBvY2N1cnJlbmNlc1xuXHRcdC8vIChpZiBhbnkpLlxuXHRcdGNvbnN0IHByb3RvY29sUmVnZXggPSAvXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OlxcL1xcLy9nO1xuXG5cdFx0bGV0IGxhc3RJbmRleCA9IDA7XG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gcHJvdG9jb2xSZWdleC5leGVjKHVybE9iamVjdC5wYXRobmFtZSk7XG5cdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwcm90b2NvbCA9IG1hdGNoWzBdO1xuXHRcdFx0Y29uc3QgcHJvdG9jb2xBdEluZGV4ID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRjb25zdCBpbnRlcm1lZGlhdGUgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCBwcm90b2NvbEF0SW5kZXgpO1xuXG5cdFx0XHRyZXN1bHQgKz0gaW50ZXJtZWRpYXRlLnJlcGxhY2UoL1xcL3syLH0vZywgJy8nKTtcblx0XHRcdHJlc3VsdCArPSBwcm90b2NvbDtcblx0XHRcdGxhc3RJbmRleCA9IHByb3RvY29sQXRJbmRleCArIHByb3RvY29sLmxlbmd0aDtcblx0XHR9XG5cblx0XHRjb25zdCByZW1uYW50ID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNsaWNlKGxhc3RJbmRleCwgdXJsT2JqZWN0LnBhdGhuYW1lLmxlbmd0aCk7XG5cdFx0cmVzdWx0ICs9IHJlbW5hbnQucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpO1xuXG5cdFx0dXJsT2JqZWN0LnBhdGhuYW1lID0gcmVzdWx0O1xuXHR9XG5cblx0Ly8gRGVjb2RlIFVSSSBvY3RldHNcblx0aWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuXHRcdHRyeSB7XG5cdFx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSBkZWNvZGVVUkkodXJsT2JqZWN0LnBhdGhuYW1lKTtcblx0XHR9IGNhdGNoIHt9XG5cdH1cblxuXHQvLyBSZW1vdmUgZGlyZWN0b3J5IGluZGV4XG5cdGlmIChvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID09PSB0cnVlKSB7XG5cdFx0b3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9IFsvXmluZGV4XFwuW2Etel0rJC9dO1xuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkgJiYgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleC5sZW5ndGggPiAwKSB7XG5cdFx0bGV0IHBhdGhDb21wb25lbnRzID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNwbGl0KCcvJyk7XG5cdFx0Y29uc3QgbGFzdENvbXBvbmVudCA9IHBhdGhDb21wb25lbnRzW3BhdGhDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuXG5cdFx0aWYgKHRlc3RQYXJhbWV0ZXIobGFzdENvbXBvbmVudCwgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkpIHtcblx0XHRcdHBhdGhDb21wb25lbnRzID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMCwgLTEpO1xuXHRcdFx0dXJsT2JqZWN0LnBhdGhuYW1lID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMSkuam9pbignLycpICsgJy8nO1xuXHRcdH1cblx0fVxuXG5cdGlmICh1cmxPYmplY3QuaG9zdG5hbWUpIHtcblx0XHQvLyBSZW1vdmUgdHJhaWxpbmcgZG90XG5cdFx0dXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG5cblx0XHQvLyBSZW1vdmUgYHd3dy5gXG5cdFx0aWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcblx0XHRcdC8vIEVhY2ggbGFiZWwgc2hvdWxkIGJlIG1heCA2MyBhdCBsZW5ndGggKG1pbjogMSkuXG5cdFx0XHQvLyBTb3VyY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvc3RuYW1lI1Jlc3RyaWN0aW9uc19vbl92YWxpZF9ob3N0X25hbWVzXG5cdFx0XHQvLyBFYWNoIFRMRCBzaG91bGQgYmUgdXAgdG8gNjMgY2hhcmFjdGVycyBsb25nIChtaW46IDIpLlxuXHRcdFx0Ly8gSXQgaXMgdGVjaG5pY2FsbHkgcG9zc2libGUgdG8gaGF2ZSBhIHNpbmdsZSBjaGFyYWN0ZXIgVExELCBidXQgbm9uZSBjdXJyZW50bHkgZXhpc3QuXG5cdFx0XHR1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sICcnKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgcXVlcnkgdW53YW50ZWQgcGFyYW1ldGVyc1xuXHRpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycykpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11c2VsZXNzLXNwcmVhZCAtLSBXZSBhcmUgaW50ZW50aW9uYWxseSBzcHJlYWRpbmcgdG8gZ2V0IGEgY29weS5cblx0XHRmb3IgKGNvbnN0IGtleSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG5cdFx0XHRpZiAodGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuXHRcdFx0XHR1cmxPYmplY3Quc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycyA9PT0gdHJ1ZSkge1xuXHRcdHVybE9iamVjdC5zZWFyY2ggPSAnJztcblx0fVxuXG5cdC8vIFNvcnQgcXVlcnkgcGFyYW1ldGVyc1xuXHRpZiAob3B0aW9ucy5zb3J0UXVlcnlQYXJhbWV0ZXJzKSB7XG5cdFx0dXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5zb3J0KCk7XG5cblx0XHQvLyBDYWxsaW5nIGAuc29ydCgpYCBlbmNvZGVzIHRoZSBzZWFyY2ggcGFyYW1ldGVycywgc28gd2UgbmVlZCB0byBkZWNvZGUgdGhlbSBhZ2Fpbi5cblx0XHR0cnkge1xuXHRcdFx0dXJsT2JqZWN0LnNlYXJjaCA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmxPYmplY3Quc2VhcmNoKTtcblx0XHR9IGNhdGNoIHt9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG5cdFx0dXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdH1cblxuXHRjb25zdCBvbGRVcmxTdHJpbmcgPSB1cmxTdHJpbmc7XG5cblx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgbWFueSBvZiB0aGUgTm9kZSBgdXJsYCBub3JtYWxpemF0aW9uc1xuXHR1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcblxuXHRpZiAoIW9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2ggJiYgdXJsT2JqZWN0LnBhdGhuYW1lID09PSAnLycgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aCgnLycpICYmIHVybE9iamVjdC5oYXNoID09PSAnJykge1xuXHRcdHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgJycpO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGVuZGluZyBgL2AgdW5sZXNzIHJlbW92ZVNpbmdsZVNsYXNoIGlzIGZhbHNlXG5cdGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gJy8nKSAmJiB1cmxPYmplY3QuaGFzaCA9PT0gJycgJiYgb3B0aW9ucy5yZW1vdmVTaW5nbGVTbGFzaCkge1xuXHRcdHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgJycpO1xuXHR9XG5cblx0Ly8gUmVzdG9yZSByZWxhdGl2ZSBwcm90b2NvbCwgaWYgYXBwbGljYWJsZVxuXHRpZiAoaGFzUmVsYXRpdmVQcm90b2NvbCAmJiAhb3B0aW9ucy5ub3JtYWxpemVQcm90b2NvbCkge1xuXHRcdHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnLy8nKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBodHRwL2h0dHBzXG5cdGlmIChvcHRpb25zLnN0cmlwUHJvdG9jb2wpIHtcblx0XHR1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXig/Omh0dHBzPzopP1xcL1xcLy8sICcnKTtcblx0fVxuXG5cdHJldHVybiB1cmxTdHJpbmc7XG59XG5cbi8vIERlcGVuZGVuY2llc1xuXG4vKipcbiAqIHBhcnNlVXJsXG4gKiBQYXJzZXMgdGhlIGlucHV0IHVybC5cbiAqXG4gKiAqKk5vdGUqKjogVGhpcyAqdGhyb3dzKiBpZiBpbnZhbGlkIHVybHMgYXJlIHByb3ZpZGVkLlxuICpcbiAqIEBuYW1lIHBhcnNlVXJsXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIGlucHV0IHVybC5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IG5vcm1hbGl6ZSBXaGV0aGVyIHRvIG5vcm1hbGl6ZSB0aGUgdXJsIG9yIG5vdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgYHRydWVgLCB0aGUgdXJsIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGJlIG5vcm1hbGl6ZWQuIElmIGFuIG9iamVjdCwgaXQgd2lsbCBiZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgb2JqZWN0IHNlbnQgdG8gW2Bub3JtYWxpemUtdXJsYF0oaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9ub3JtYWxpemUtdXJsKS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgU1NIIHVybHMsIG5vcm1hbGl6ZSB3b24ndCB3b3JrLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKlxuICogICAgLSBgcHJvdG9jb2xzYCAoQXJyYXkpOiBBbiBhcnJheSB3aXRoIHRoZSB1cmwgcHJvdG9jb2xzICh1c3VhbGx5IGl0IGhhcyBvbmUgZWxlbWVudCkuXG4gKiAgICAtIGBwcm90b2NvbGAgKFN0cmluZyk6IFRoZSBmaXJzdCBwcm90b2NvbCwgYFwic3NoXCJgIChpZiB0aGUgdXJsIGlzIGEgc3NoIHVybCkgb3IgYFwiZmlsZVwiYC5cbiAqICAgIC0gYHBvcnRgIChudWxsfE51bWJlcik6IFRoZSBkb21haW4gcG9ydC5cbiAqICAgIC0gYHJlc291cmNlYCAoU3RyaW5nKTogVGhlIHVybCBkb21haW4gKGluY2x1ZGluZyBzdWJkb21haW5zKS5cbiAqICAgIC0gYHVzZXJgIChTdHJpbmcpOiBUaGUgYXV0aGVudGljYXRpb24gdXNlciAodXN1YWxseSBmb3Igc3NoIHVybHMpLlxuICogICAgLSBgcGF0aG5hbWVgIChTdHJpbmcpOiBUaGUgdXJsIHBhdGhuYW1lLlxuICogICAgLSBgaGFzaGAgKFN0cmluZyk6IFRoZSB1cmwgaGFzaC5cbiAqICAgIC0gYHNlYXJjaGAgKFN0cmluZyk6IFRoZSB1cmwgcXVlcnlzdHJpbmcgdmFsdWUuXG4gKiAgICAtIGBocmVmYCAoU3RyaW5nKTogVGhlIGlucHV0IHVybC5cbiAqICAgIC0gYHF1ZXJ5YCAoT2JqZWN0KTogVGhlIHVybCBxdWVyeXN0cmluZywgcGFyc2VkIGFzIG9iamVjdC5cbiAqICAgIC0gYHBhcnNlX2ZhaWxlZGAgKEJvb2xlYW4pOiBXaGV0aGVyIHRoZSBwYXJzaW5nIGZhaWxlZCBvciBub3QuXG4gKi9cbmNvbnN0IHBhcnNlVXJsID0gKHVybCwgbm9ybWFsaXplID0gZmFsc2UpID0+IHtcblxuICAgIC8vIENvbnN0YW50c1xuICAgIGNvbnN0IEdJVF9SRSA9IC9eKD86KFthLXpfXVthLXowLTlfLV17MCwzMX0pQHxodHRwcz86XFwvXFwvKShbXFx3XFwuXFwtQF0rKVtcXC86XShbXFx+LFxcLlxcdyxcXC0sXFxfLFxcL10rPyg/OlxcLmdpdHxcXC8pPykkLztcblxuICAgIGNvbnN0IHRocm93RXJyID0gbXNnID0+IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGVyci5zdWJqZWN0X3VybCA9IHVybDtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiIHx8ICF1cmwudHJpbSgpKSB7XG4gICAgICAgIHRocm93RXJyKFwiSW52YWxpZCB1cmwuXCIpO1xuICAgIH1cblxuICAgIGlmICh1cmwubGVuZ3RoID4gcGFyc2VVcmwuTUFYX0lOUFVUX0xFTkdUSCkge1xuICAgICAgICB0aHJvd0VycihcIklucHV0IGV4Y2VlZHMgbWF4aW11bSBsZW5ndGguIElmIG5lZWRlZCwgY2hhbmdlIHRoZSB2YWx1ZSBvZiBwYXJzZVVybC5NQVhfSU5QVVRfTEVOR1RILlwiKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBub3JtYWxpemUgPSB7XG4gICAgICAgICAgICAgICAgc3RyaXBIYXNoOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBub3JtYWxpemVVcmwodXJsLCBub3JtYWxpemUpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlUGF0aF9fZGVmYXVsdFtcImRlZmF1bHRcIl0odXJsKTtcblxuICAgIC8vIFBvdGVudGlhbCBnaXQtc3NoIHVybHNcbiAgICBpZiAocGFyc2VkLnBhcnNlX2ZhaWxlZCkge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gcGFyc2VkLmhyZWYubWF0Y2goR0lUX1JFKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgcGFyc2VkLnByb3RvY29scyA9IFtcInNzaFwiXTtcbiAgICAgICAgICAgIHBhcnNlZC5wcm90b2NvbCA9IFwic3NoXCI7XG4gICAgICAgICAgICBwYXJzZWQucmVzb3VyY2UgPSBtYXRjaGVkWzJdO1xuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVkWzJdO1xuICAgICAgICAgICAgcGFyc2VkLnVzZXIgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYC8ke21hdGNoZWRbM119YDtcbiAgICAgICAgICAgIHBhcnNlZC5wYXJzZV9mYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyKFwiVVJMIHBhcnNpbmcgZmFpbGVkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG5wYXJzZVVybC5NQVhfSU5QVVRfTEVOR1RIID0gMjA0ODtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVVybDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js\n");

/***/ })

};
;